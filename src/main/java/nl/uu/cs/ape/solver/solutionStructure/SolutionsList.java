package nl.uu.cs.ape.solver.solutionStructure;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

import lombok.extern.slf4j.Slf4j;
import nl.uu.cs.ape.configuration.APEConfigException;
import nl.uu.cs.ape.configuration.APERunConfig;
import nl.uu.cs.ape.models.Pair;
import nl.uu.cs.ape.models.SATAtomMappings;
import nl.uu.cs.ape.models.enums.SolverType;
import nl.uu.cs.ape.models.enums.SynthesisFlag;

/**
 * The {@code All_solutions} class is used to store all the SAT solutions
 * generated by the program, together with the corresponding mappings.
 *
 * @author Vedran Kasalica
 */
@Slf4j
public class SolutionsList {

    private List<SolutionWorkflow> solutions = new ArrayList<>();

    /**
     * Max number of solutions that should be found.
     */
    private final int maxSolutions;

    /**
     * Mapping of predicates into integers (for SAT encoding).
     */
    private final SATAtomMappings mappings = new SATAtomMappings();

    /**
     * Current solution index.
     */
    private int solutionIndex = 0;
    /**
     * APE run configuration.
     */
    private final APERunConfig runConfig;

    /**
     * Synthesis result flag, i.e., the reason why the synthesis execution was
     * interrupted.
     */
    private SynthesisFlag runFlag;

    /**
     * Total synthesis solving time in MS.
     */
    private long synthesisTimeMS;

    /**
     * Pars of the numbeR of solutions found at each workflow length.
     */
    private List<Pair<Integer>> solutionsPerLength;

    /**
     * Create an object that will contain all the solutions of the synthesis.
     *
     * @param runConfig - setup configuration for the synthesis run.
     */
    public SolutionsList(APERunConfig runConfig) {
        this.runConfig = runConfig;

        /* Variables defining the current and maximum lengths and solutions count. */
        this.maxSolutions = runConfig.getMaxNoSolutions();
        if (this.maxSolutions > 100) {
            log.info("Looking for " + maxSolutions + " solutions might take some time.");
        }
    }

    /**
     * Get the number of solutions that are currently found.
     *
     * @return Number of solutions in the solutions set.
     */
    public int getNumberOfSolutions() {
        return this.solutions.size();
    }

    /**
     * Get max number of solutions that should be found. This number is defined in
     * the config.json file.
     *
     * @return Max number of solutions that should be found.
     */
    public int getMaxNumberOfSolutions() {
        return maxSolutions;
    }

    /**
     * Get object that contains mappings of all the atoms.
     *
     * @return The {@link SATAtomMappings} object.
     */
    public SATAtomMappings getMappings() {
        return mappings;
    }

    /**
     * Returns true if the list of all the solutions contains no elements.
     *
     * @return true if the list contains no elements.
     */
    public boolean isEmpty() {
        return this.solutions.isEmpty();
    }

    /**
     * Get the ape run configuration available at the start.
     * 
     * @return the object that contains the run configuration information.
     */
    public APERunConfig getRunConfiguration() {
        return runConfig;
    }

    /**
     * Appends all of the elements in the specified collection to the end of this
     * list, in the order
     * that they are returned by the specified collection's iterator (optional
     * operation). The behavior
     * of this operation is undefined if the specified collection is modified while
     * the operation
     * is in progress. (Note that this will occur if the specified collection is
     * this list,
     * and it's nonempty.)
     *
     * @param currSolutions Solutions that should be added to the list of all
     *                      solutions.
     * @return true if this list changed as a result of the call.
     */
    public boolean addSolutions(List<SolutionWorkflow> currSolutions) {
        for (SolutionWorkflow solution : currSolutions) {
            solution.setIndex(solutionIndex++);
            this.solutions.add(solution);
        }
        return false;
    }

    /**
     * Get solution workflow.
     *
     * @param index the index
     * @return the solution workflow
     */
    public SolutionWorkflow get(int index) {
        return this.solutions.get(index);
    }

    /**
     * Returns the number of elements in this list.
     * If this list contains more than Integer.MAX_VALUE elements,
     * returns Integer.MAX_VALUE.
     *
     * @return The number of elements in this list.
     */
    public int size() {
        return this.solutions.size();
    }

    /**
     * Set a specific number to be the number of solutions that are found up to the
     * specified length.
     * 
     * @param length      - the length up until which the solutions are evaluated
     * @param noSolutions - number of solutions that can be found up until the given
     *                    length
     */
    public void addNoSolutionsForLength(Integer length, Integer noSolutions) {
        if (noSolutions == 0)
            return;
        if (solutionsPerLength == null) {
            solutionsPerLength = new ArrayList<>();
        }
        solutionsPerLength.add(new Pair<Integer>(length, noSolutions));
    }

    /**
     * Returns list of pairs (X, Y), where Y describes the number of solutions up
     * until length X.
     * 
     * @return
     */
    public List<Pair<Integer>> getSolutionsPerLength() {
        return solutionsPerLength;
    }

    /**
     * Return the stream that represent the solutions.
     *
     * @return list of solutions.
     */
    public Stream<SolutionWorkflow> getStream() {
        return this.solutions.stream();
    }

    /**
     * Return a potentially parallel stream that represent the solutions.
     *
     * @return list of solutions.
     */
    public Stream<SolutionWorkflow> getParallelStream() {
        return this.solutions.parallelStream();
    }

    /**
     * Set the synthesis result flag, i.e., set the reason why the synthesis
     * execution was interrupted.
     * 
     * @param flag - the {@link SynthesisFlag} that should be set
     */
    public void setFlag(SynthesisFlag flag) {
        this.runFlag = flag;

    }

    /**
     * Get the synthesis result flag, i.e., the reason why the synthesis execution
     * was interrupted.
     * 
     * @return Returns the {@link SynthesisFlag} representing the reason synthesis
     *         execution was interrupted.
     */
    public SynthesisFlag getFlag() {
        return runFlag;
    }

    /**
     * Get total synthesis time (in MS).
     * 
     * @return the total synthesis time in MS.
     */
    public long getSolvingTime() {
        return this.synthesisTimeMS;
    }

    /**
     * Set total synthesis time (in MS).
     * 
     * @param synthesisTimeMS the synthesis time in MS
     */
    public void setSolvingTime(long synthesisTimeMS) {
        this.synthesisTimeMS = synthesisTimeMS;
    }

}
